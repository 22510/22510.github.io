<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>ADT树——C语言实现 | 佛耶戈的狗窝</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://22510.github.io/favicon.ico?v=1647853207577">
<link rel="stylesheet" href="https://22510.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="数据结构——树
PS:新人博客，如有错误欢迎在评论区指正

前置知识：递归，结构体

基础概念

根节点只存在一个
节点拥有子树的个数为节点的度
除了根节点一外的，都是子树

子树个数没有限制，子树之间互不相交


结点间的亲缘关系：如图示..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://22510.github.io">
        <img src="https://22510.github.io/images/avatar.png?v=1647853207577" class="site-logo">
        <h1 class="site-title">佛耶戈的狗窝</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      痛，太痛了
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://22510.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">ADT树——C语言实现</h2>
            <div class="post-date">2022-03-21</div>
            
            <div class="post-content" v-pre>
              <h1 id="数据结构树">数据结构——树</h1>
<p>PS:新人博客，如有错误欢迎在评论区指正</p>
<ul>
<li>前置知识：递归，结构体</li>
</ul>
<h2 id="基础概念">基础概念</h2>
<ol>
<li>根节点只存在一个</li>
<li>节点拥有子树的个数为节点的度</li>
<li>除了根节点一外的，都是子树
<ul>
<li>子树个数没有限制，子树之间互不相交</li>
</ul>
</li>
<li>结点间的亲缘关系：如图示</li>
<li>从根节点开始向下数，树的层数即是树的深度</li>
<li>森林：互补相交的树<br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320210042579-1430382689.png" alt="image" loading="lazy"></li>
</ol>
<h2 id="树的存储结构">树的存储结构</h2>
<ul>
<li>存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否合适、方便，时间复杂度好不好等——《大话数据结构》</li>
</ul>
<h3 id="双亲表示法">双亲表示法</h3>
<blockquote>
<p>采用数组来存储：顺序存储各个节点，给各节点附加记录其 parent 节点位置<br>
每个节点中，包含该节点的数据和该节点的 parent 节点的位置<br>
除了知道自己是谁，自己存放什么内容，还知道自己的 parent 在哪<br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320210543692-569014984.png" alt="image" loading="lazy"><br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320211602325-1141923800.png" alt="image" loading="lazy"></p>
</blockquote>
<pre><code class="language-c">#define MAX_TREE_SIZE 100 //树的最大尺寸
typedef int TElemType;    //树节点的数据类型
typedef struct PTNode{	  //节点结构
	TElemType data;		  //节点数据
	int parent;			  //parent 位置
}PTNode;
typedef struct{
	PTNode nodes[MAX_TREE_SIZE];//节点数组
	int r,n;			  //根的位置和节点数
}PTree;
</code></pre>
<blockquote>
<p>易于找到 parent 节点，但在寻找节点的 child 时，需要遍历整个树</p>
</blockquote>
<h3 id="孩子表示法">孩子表示法</h3>
<blockquote>
<p>每个节点指向一颗子树的根节点——多重链式表示法</p>
</blockquote>
<h4 id="实现方法一">实现方法一</h4>
<ul>
<li>为给一个节点设置最大值<br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320214135281-133531180.png" alt="image" loading="lazy"></li>
</ul>
<h4 id="实现方法二">实现方法二</h4>
<ul>
<li>对比于方法一无法确定节点的度，我们可以设置一个变量来记录节点的度，进而设计适当的个数，减少空指针浪费空间<br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320214848513-1790398188.png" alt="image" loading="lazy"></li>
</ul>
<blockquote>
<p>克服空间浪费，但节点的链表结构不同，还要维护节点度的数值，会产生时间消耗（空间换时间，时间换空间）</p>
</blockquote>
<h2 id="二叉树">二叉树</h2>
<h3 id="二叉树基础概念">二叉树基础概念</h3>
<blockquote>
<p>在没有指定规则的情况下，其他形式树的创建比较困难，所以一般创建二叉树来学习树的数据类型<br>
每个根节点最多只有两个子树<br>
左子树和右子树是有区别的<br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320225201566-1108325721.png" alt="image" loading="lazy"></p>
</blockquote>
<ul>
<li>二叉树与非常经典的二分查找算法有一些关联，我们在将一组数据输入时，可以依照二分查找（大小关系）输入树中，并且在查找的时候也比较快捷（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>)<br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320230506809-1888373602.png" alt="image" loading="lazy">
<ul>
<li>但很明显可以发现，如果所选取的根节点不好，就会导致树长得比较奇葩，甚至长成斜树</li>
</ul>
</li>
<li>斜树：左斜树 and 右斜树，每层都只有一个节点，所有节点都全是左子树（右子树）<img src="uploading..." alt="image" loading="lazy"><br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320231052444-2057387942.png" alt="image" loading="lazy"></li>
<li>满二叉树：全部节点都存在的二叉树<br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320231332829-1227111085.png" alt="image" loading="lazy"></li>
<li>完全二叉树：其序号按照满二叉树来标注，看图可知
<ul>
<li>满二叉树一定是完全二叉树，但反过来不一定<br>
<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220320231821393-850335330.png" alt="image" loading="lazy"></li>
</ul>
</li>
</ul>
<h3 id="二叉树存储结构">二叉树存储结构</h3>
<ul>
<li>可以类比前基本树的存储结构</li>
</ul>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<blockquote>
<p>从根节点出发，按照某种次序依次访问二叉树中的所有节点，使得每个节点被访问且仅被访问一次</p>
</blockquote>
<h4 id="前序遍历先访问根节点然后遍历左节点再遍历右节点abdghceif">前序遍历：先访问根节点，然后遍历左节点，再遍历右节点：ABDGHCEIF</h4>
<p><img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220321081229001-405271000.png" alt="image" loading="lazy"><br>
1. 先从根节点进入，访问A<br>
2. 再进一步访问A的左子树B<br>
3. 依次向左下访问：D-&gt;G，由于G没有子树，所以返回节点D，访问右子树H<br>
PS：这里我们是使用<strong>递归</strong>来实现的二叉树，所以会有返回操作，看到完整代码即可理解<br>
4. D节点的树已经访问完，返回到B节点，B节点没有右子树，返回A节点<br>
5. 右边的访问类比左边即可，规则一样</p>
<ul>
<li>代码实现</li>
</ul>
<pre><code class="language-c">void PreOrdeTraverse(BiTree T)
{
    if (T)		//树不空则继续访问
    {
        printf(T-&gt;data);
        PreOrdeTraverse(T-&gt;lchild);//使用递归形式实现遍历，所以需要下层左树访问完全，才能返回到节点，访问右树
        PreOrdeTraverse(T-&gt;rchild);
    }
}
</code></pre>
<h4 id="中序遍历从根节点开始并不访问根节点先遍历节点左树再访问根节点后访问右树gdhbaeicf">中序遍历：从根节点开始（并不访问根节点），先遍历节点左树，再访问根节点，后访问右树：GDHBAEICF</h4>
<figure data-type="image" tabindex="1"><img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220321082620670-1152145237.png" alt="image" loading="lazy"></figure>
<ul>
<li>先看代码，更好的理解中序遍历</li>
</ul>
<pre><code class="language-c">void InOrdeTraverse(BiTree T)
{
    if (T)
    {
        InOrdeTraverse(T-&gt;lchild);
        printf(T-&gt;data);
        InOrdeTraverse(T-&gt;rchild);
    }
}
</code></pre>
<pre><code>1. 依旧是从A节点进入，但看程序，我们会优先进行`InOrdeTraverse(T-&gt;lchild)`，访问左子树
2. B-&gt;D-&gt;G
3. 当到达G节点时，没有左子树了，我们便输出G的内容printf(T-&gt;date)；G节点无右子树，所以本节点递归结束，回到D节点printf(T-&gt;data)，接着访问H节点，同样H节点无左右子树，便printf(T-&gt;data)
4. 其他同样如此理解
</code></pre>
<h4 id="后序遍历从根节点进入先访问左子树再访问右子树最后放过根节点">后序遍历：从根节点进入，先访问左子树，再访问右子树，最后放过根节点</h4>
<figure data-type="image" tabindex="2"><img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220321084138120-1114966871.png" alt="image" loading="lazy"></figure>
<ul>
<li>类比前两种遍历方式，不多赘述</li>
</ul>
<pre><code class="language-c">void PosOrdeTraverse(BiTree T)
{
    if (T)
    {
        PosOrdeTraverse(T-&gt;lchild);
        PosOrdeTraverse(T-&gt;rchild);
        visit(T-&gt;data);
    }
}
</code></pre>
<h4 id="层序遍历按照层级关系对树进行遍历使用队列实现abcdefghi">层序遍历：按照层级关系对树进行遍历；使用队列实现：ABCDEFGHI</h4>
<figure data-type="image" tabindex="3"><img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220321164903886-1968328431.png" alt="image" loading="lazy"></figure>
<pre><code class="language-c">#define maxsize 30 //队列最大长度
//访问二叉树结点操作
void visit(char c)
{
    printf(&quot;%c&quot;, c);
}
//层序遍历队列结构
typedef struct
{
    BiTree data[maxsize];
    int front, rear; //前后
} SqQueue;
//初始化队列
void InitQueue(SqQueue *Q)
{
    Q-&gt;front = Q-&gt;rear = 0;
}
//入队
void EnQueue(SqQueue *Q, BiTree P)
{
    if ((Q-&gt;rear + 1) % maxsize == Q-&gt;front)
    {
        printf(&quot;this Queue is full&quot;);
    }
    else
    {
        Q-&gt;data[Q-&gt;rear] = P;
        Q-&gt;rear = (Q-&gt;rear + 1) % maxsize;
    }
}
//出队
void DeQueue(SqQueue *Q, BiTree *P)
{
    if (Q-&gt;front == Q-&gt;rear)
    {
        printf(&quot;this queue is full&quot;);
    }
    else
    {
        *P = Q-&gt;data[Q-&gt;front];
        Q-&gt;front = (Q-&gt;front + 1) % maxsize;
    }
}
int emptyQueue(SqQueue Q)
{
    if (Q.front == Q.rear)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
//层序遍历二叉树
void LevelOrder(BiTree T)
{
    SqQueue Q;
    InitQueue(&amp;Q);
    BiTree P;
    EnQueue(&amp;Q, T);
    while (!emptyQueue(Q))
    {
        DeQueue(&amp;Q, &amp;P);
        visit(P-&gt;data);
        if (P-&gt;lchild != NULL)
        {
            EnQueue(&amp;Q, P-&gt;lchild);
        }
        if (P-&gt;rchild != NULL)
        {
            EnQueue(&amp;Q, P-&gt;rchild);
        }
    }
}
</code></pre>
<h3 id="总的代码汇集">总的代码汇集</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
//使用递归实现树
#define maxsize 30
typedef struct BiTNode
{
    char data;                       //结点的数据域
    struct BiTNode *lchild, *rchild; //指向左孩子和右孩子
} BiTNode, *BiTree;
//访问二叉树结点操作
void visit(char c)
{
    printf(&quot;%c&quot;, c);
}
//层序遍历队列结构
typedef struct
{
    BiTree data[maxsize];
    int front, rear; //前后
} SqQueue;
//初始化队列
void InitQueue(SqQueue *Q)
{
    Q-&gt;front = Q-&gt;rear = 0;
}
//入队
void EnQueue(SqQueue *Q, BiTree P)
{
    if ((Q-&gt;rear + 1) % maxsize == Q-&gt;front)
    {
        printf(&quot;this Queue is full&quot;);
    }
    else
    {
        Q-&gt;data[Q-&gt;rear] = P;
        Q-&gt;rear = (Q-&gt;rear + 1) % maxsize;
    }
}
//出队
void DeQueue(SqQueue *Q, BiTree *P)
{
    if (Q-&gt;front == Q-&gt;rear)
    {
        printf(&quot;this queue is full&quot;);
    }
    else
    {
        *P = Q-&gt;data[Q-&gt;front];
        Q-&gt;front = (Q-&gt;front + 1) % maxsize;
    }
}
int emptyQueue(SqQueue Q)
{
    if (Q.front == Q.rear)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
//层序遍历二叉树
void LevelOrder(BiTree T)
{
    SqQueue Q;
    InitQueue(&amp;Q);
    BiTree P;
    EnQueue(&amp;Q, T);
    while (!emptyQueue(Q))
    {
        DeQueue(&amp;Q, &amp;P);
        visit(P-&gt;data);
        if (P-&gt;lchild != NULL)
        {
            EnQueue(&amp;Q, P-&gt;lchild);
        }
        if (P-&gt;rchild != NULL)
        {
            EnQueue(&amp;Q, P-&gt;rchild);
        }
    }
}

//先序序列创建一颗二叉树
void CreatBiTree(BiTree *T)
{
    char c;
    scanf(&quot;%c&quot;, &amp;c);
    if (c == '#')
        *T = NULL;
    else
    {
        *T = (BiTNode *)malloc(sizeof(BiTNode)); //给结点申请一个空间
        (*T)-&gt;data = c;
        CreatBiTree(&amp;((*T)-&gt;lchild)); //创建左子树
        CreatBiTree(&amp;((*T)-&gt;rchild)); //创建右子树
    }
}

//先序遍历二叉树
void PreOrdeTraverse(BiTree T)
{
    if (T)
    {
        visit(T-&gt;data);
        PreOrdeTraverse(T-&gt;lchild);
        PreOrdeTraverse(T-&gt;rchild);
    }
}
//中序遍历二叉树
void InOrdeTraverse(BiTree T)
{
    if (T)
    {
        InOrdeTraverse(T-&gt;lchild);
        visit(T-&gt;data);
        InOrdeTraverse(T-&gt;rchild);
    }
}
//后序遍历二叉树
void PosOrdeTraverse(BiTree T)
{
    if (T)
    {
        PosOrdeTraverse(T-&gt;lchild);
        PosOrdeTraverse(T-&gt;rchild);
        visit(T-&gt;data);
    }
}
//查找字母D在第几层
void Search(BiTree T, int leavel)
{
    if (T)
    {
        if (T-&gt;data == 'D')
        {
            printf(&quot;D在第%d层！\n&quot;, leavel);
        }
        Search(T-&gt;lchild, leavel + 1);
        Search(T-&gt;rchild, leavel + 1);
    }
}
//计算节点个数
int sumNode(BiTree T, int *count)
{
    if (T)
    {
        *count += 1;
        sumNode(T-&gt;lchild, count);
        sumNode(T-&gt;rchild, count);
    }
    return *count;
}
int main()
{
    BiTree T;
    int level = 1;
    int count = 0;
    printf(&quot;请输入先序创建的二叉树，以#结束：&quot;);
    CreatBiTree(&amp;T);
    printf(&quot;正在先序打印二叉树：&quot;);
    PreOrdeTraverse(T);
    putchar('\n');
    printf(&quot;正在中序打印二叉树：&quot;);
    InOrdeTraverse(T);
    putchar('\n');
    printf(&quot;正在后序打印二叉树：&quot;);
    PosOrdeTraverse(T);
    printf(&quot;正在层序打印二叉树：&quot;);
    LevelOrder(T);
    putchar('\n');
    printf(&quot;Nodes = %d\n&quot;, sumNode(T, &amp;count));
    Search(T, level);
    return 0;
}
</code></pre>
<ul>
<li>运行结果<img src="https://img2022.cnblogs.com/blog/2626881/202203/2626881-20220321165440553-199919762.png" alt="image" loading="lazy"></li>
</ul>
<p>####谢谢观看<br>
by https://www.cnblogs.com/QingaceLi/p/16030689.html<br>
end；</p>

            </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
